#!/usr/bin/python

#
# 'set_manual_boundaries.py'
#
#   Script implemented to work with trimAl to analyze gaps statistics and decide
#   which are the boundaries in a given alignment - columns inbetween these
#   boundaries will not be removed independently of the trimming strategy
#   selected.
#
#   [2014] S. Capella-Gutierrez - scapella@crg.es
#
#   this script is free software: you can redistribute it and/or modify it under
#   the terms of the GNU General Public License as published by the Free
#   Software Foundation, the last available version.
#
#   this script is distributed in the hope that it will be useful, but WITHOUT
#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
#   more details on <http://www.gnu.org/licenses/>
#

import os
import sys
import argparse
from string import strip

def main():

  parser = argparse.ArgumentParser()

  parser.add_argument("-i", "--input", dest = "inFile", required = True,
    type = str, help = "Output file containing gaps stats generated by trimAl"
    + " - option -sgc")

  parser.add_argument("--min_gapscore_allowed", dest = "minGapBoundaries", \
    type = float, default = .8, help = "Set the minimum gap score (1 - fraction"
      + "of gaps) which we will use to set the boundaries when there are not "
      + "two columns with no gaps - default 0.8")

  parser.add_argument("--get_best_boundaries", dest = "bestBoundaries", default
    = False, action = "store_true", help = "Get the best possible boundaries")

  parser.add_argument("--discard_nogaps_columns", dest = "discardNoGaps",
    default = False, action = "store_true", help = "Discard those columns with"
    + "no gaps - those columns will be preferentially selected as boundaries")

  args = parser.parse_args()

  if not os.path.isfile(args.inFile):
    sys.exit("ERROR: The input file should be defined")

  if args.minGapBoundaries < 0 or args.minGapBoundaries > 1:
    sys.exit("ERROR: --min_gapscore_allow should be defined in the range [0,1]")

  npos = 0
  putative = [0, 0, False, 0, 0]
  boundaries = [-1, -1, -1, -1, -1, -1]
  for line in open(args.inFile, "rU"):
    ## Discard any line containing text
    if line[0] in ["#", "|", "+"]:
      continue

    f = [chunk for chunk in map(strip, line.split("\t")) if chunk]
    if not f:
      continue
    npos += 1
    pos = int(f[0])
    gap_score = float(f[2])

    if gap_score >= args.minGapBoundaries:
      ## Check whether the left boundary is defined, if that the case, define
      ## the right one
      if boundaries[0] != -1:

        ## We update constantently the right boundary until the last best value
        ## is found
        if gap_score > boundaries[4] and gap_score != 1.0:
          boundaries[4] = gap_score
          boundaries[3] = pos

        if gap_score == 1.0:
          boundaries[5] = pos

      ## Define the left boundary as the first value passing the input parameters
      else:
        if gap_score > boundaries[1] and gap_score != 1.0:
          boundaries[1] = gap_score
          boundaries[0] = pos

      if gap_score == 1.0 and boundaries[2] == -1:
        boundaries[2] = pos

    else:
      ## Try to get the best potential cutting points below to the input
      ## thresholds - it would be useful if we don't found the boundaries

      ## We will update the right boundary constantly
      if gap_score > putative[4]:
          putative[4] = gap_score
          putative[3] = pos

      ## We update current value until the left boundary is found
      if boundaries[0] == -1:

        ## Any pick on values - reflected like the ta least the double of the
        ## current best value, should be store.
        if gap_score > (2 * putative[1]):
          putative[1] = gap_score
          putative[2] = False
          putative[0] = pos

        ## We update the left boundaries if and only if the immediate previous
        ## position has at least a similar value
        if not putative[2] and gap_score >= putative[1]:
          putative[1] = gap_score
          putative[0] = pos
        else:
          putative[2] = True

  output = ""
  ## Generate output, if any
  if boundaries[0] != -1 and boundaries[3] != -1:
    if boundaries[2] != -1 and boundaries[2] != boundaries[5] \
      and not args.discardNoGaps:
        output += ("## %-30s\t1.0000\t") % ("NO Gaps Left Boundary")
        output += ("pos\t%d\t%%alig\t%.4f") % (boundaries[2], \
          float(boundaries[2])/npos)
    else:
        output =  ("## %-30s\t") % ("Best Gaps_Score Left Boundary")
        output += ("%.4f\tpos\t%d\t%%alig\t%.4f") % (boundaries[1],
          boundaries[0], float(boundaries[0])/npos)
    if boundaries[5] != -1 and boundaries[2] != boundaries[5] \
      and not args.discardNoGaps:
        output += ("\n## %-30s\t1.0000\t") % ("NO Gaps Right Boundary")
        output += ("pos\t%d\t%%alig\t%.4f") % (boundaries[5], \
          float(boundaries[5])/npos)
    else:
        output += ("\n## %-30s\t") % ("Best Gaps_Score Right Boundary")
        output += ("%.4f\tpos\t%d\t%%alig\t%.4f") % (boundaries[4],
          boundaries[3], float(boundaries[3])/npos)

  ## If there is no output, and the user has set-up "--get_best_boundaries"
  if not output and args.bestBoundaries:
    output =  ("## %-30s\t") % ("Best_found Gaps_Score Left Boundary")
    output += ("%.4f\tpos\t%d\t%%alig\t%.4f\n") % (putative[1],
      putative[0], float(putative[0])/npos)
    output += ("## %-30s\t") % ("Best_found Gaps_Score Right Boundary")
    output += ("%.4f\tpos\t%d\t%%alig\t%.4f") % (putative[4],
      putative[3], float(putative[3])/npos)

  ## Generate a warning for those cases where no boundaries have been found
  if not output:
    output = "WARNING: OUTPUT NOT AVAILABLE"
  print output
### ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ****
if __name__ == "__main__":
  sys.exit(main())

